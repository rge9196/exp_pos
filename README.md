# Small retail POS Application

## 1. Overview

This project is a lightweight Point-of-Sale (POS) system designed for small food retail operations.
It is built for fast counter workflows, clear operational controls, and practical audit visibility.

The application is intended for small to mid-sized retail food environments where speed, cashier usability, and reliable reporting are priorities.

## 2. Features

- Checkout with split payments
- Change calculation
- Order history and detail view
- Void and refund flows
- Z report (date-based)
- Product sales report (grouped by product and price)
- Receipt printing (80mm)
- Audit-friendly design

## 3. Architecture Overview

```text
+-----------------------+      HTTP/JSON      +---------------------+      SQL      +------------------+
| Frontend (React/Vite) |  -----------------> | Backend API (Flask) |  -----------> | SQLite Database  |
| Zustand + Tailwind    | <------------------ | JWT Cookie Auth     | <-----------  | pos.db           |
+-----------------------+                     +---------------------+                +------------------+
```

## 4. Frontend Structure

### Pages

- `Home`: landing screen
- `Orders`: active order entry workspace
- `Checkout`: payment allocation and confirmation
- `Ticket`: print-focused receipt view after sale
- `OrderHistory`: searchable/filterable list of past orders
- `OrderDetail`: detailed receipt-style view of a historical order
- `ZReport`: date-based sales summary
- `ProductReport`: product sales grouped by product and unit price
- `Login` and `Register`: authentication views (register can be reached directly by route)

### Zustand Stores

- `authStore`: session state, login/logout, current user lookup
- `orderStore`: active cart lines, split payments, totals, last order snapshot
- `paymentMethodsStore`: loads available payment methods from backend
- `productsStore`: product catalog loading for order entry

### Routing Structure

Core routes in `frontend/src/App.jsx`:

- `/` home
- `/login`
- `/register`
- `/orders`
- `/checkout`
- `/ticket/:id`
- `/history`
- `/orders/:id`
- `/reports/z`
- `/reports/products`

### Styling Approach

The UI uses Tailwind CSS utility classes with a consistent dark POS theme and pragmatic, low-friction layouts focused on cashier speed.

## 5. Backend API

### Auth

- `POST /api/login`
- `POST /api/logout`
- `GET /api/me`

### Orders

- `POST /api/orders`
- `GET /api/orders`
- `GET /api/orders/<id>` (frontend route equivalent: `/api/orders/:id`)
- `POST /api/orders/<id>/void` (frontend route equivalent: `/api/orders/:id/void`)
- `POST /api/orders/<id>/refund` (frontend route equivalent: `/api/orders/:id/refund`)

### Reports

- `GET /api/reports/z`
- `GET /api/reports/products`

### Payment Methods

- `GET /api/payment-methods`

## 6. Database Schema Overview

High-level tables:

- `users`: cashier/operator accounts
- `products`: sellable catalog items and baseline pricing metadata
- `orders`: order headers, totals, timestamps, status
- `order_lines`: per-item quantities, unit prices, line totals
- `payments`: payment allocations by method per order
- `payment_methods`: cash/card/deposit definitions

Key design principles:

- All monetary values are stored as integer cents.
- Audit data is retained rather than deleted.
- Refunds are stored as negative financial values.
- Voided orders are retained for traceability but excluded from report totals.

### Time Storage and Conversion

- `orders.created_at` is stored as SQLite `CURRENT_TIMESTAMP` (UTC).
- Stored timestamps are never rewritten for timezone conversion.
- Date-range filtering for reporting and history uses local business time (UTC-6) at query time with:
  `date(datetime(created_at, '-6 hours'))`
- This conversion is applied in:
  - `GET /api/reports/z`
  - `GET /api/reports/products`
  - `GET /api/orders` (history list)

## 7. Reporting Philosophy

This system uses date-based reporting instead of register open/close session accounting.

- No open/close sessions are required.
- Reports are generated by date ranges using UTC-6 business-day boundaries during SQL filtering.
- This approach supports straightforward reconciliation and easier audit review across shifts and days.

## 8. Running the App

### Backend Setup

1. Activate the backend virtual environment:
   `source backend/.venv/bin/activate`
2. If dependencies are missing, install:
   `pip install flask flask-jwt-extended cs50 werkzeug`
3. Start the API server:
   `python backend/app.py`

Backend runs on `http://localhost:5000`.

### Frontend Setup

1. Install frontend dependencies:
   `cd frontend && npm install`
2. Start Vite dev server:
   `npm run dev`

Frontend runs on Vite (typically `http://localhost:5173`) and proxies `/api` to backend port `5000`.

### Database Initialization

DATABASE SETUP

This application uses a local SQLite database located at:

    backend/pos.db

The database file is NOT included in the repository.
After cloning or forking the project, you must create it using the provided schema.

---

1. Create the database

---

From the project root, run:

    sqlite3 backend/pos.db < backend/schema.sql

This will create all required tables and seed initial data.

---

2. Create the first user

---

User registration is intended for administrative setup and is hidden from the main UI.

To create the initial cashier/admin account:

1. Start the backend and frontend servers.
2. Open your browser and navigate directly to:

   http://localhost:5173/register

3. Register the first user.

After this step, the application can be used normally via the login screen.

---

## NOTES

• Do not commit pos.db if it contains real data.
• The schema script is safe to run on a new database.
• In production, use controlled user provisioning instead of public registration.

## 9. Future Enhancements (Roadmap)

- Deposit / advance payments
- Cash drawer reconciliation workflows
- Inventory tracking integration
- Multi-terminal synchronization
- CSV export options for operational and financial reporting

## 10. License / Notes

This is an experimental POS project intended for iterative development and operational validation.
Review and harden security, compliance, and operational controls before production deployment.
